<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>AI VIN Scanner</title>
    <style>
      #vinBox a {
        color: #28a745;
      }
      /* Global Reset & Box-Sizing */
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        font-family: sans-serif;
        margin: 0;
        background: #f5f5f5;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        padding: 0.5rem; /* Mobile-first padding */
        position: relative;
        width: 100%;
        overflow-x: hidden;
        /* --- FIX: Keep scrollbar always present to prevent layout shifts --- */
        overflow-y: scroll;
      }

      h2 {
        margin-top: 1rem;
        text-align: center;
        width: 100%;
      }

      /* Main Content Area */
      #mainContent {
        width: 100%;
        max-width: 480px; /* Constrain width on all screens */
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-grow: 1;
        min-width: 0;
      }

      /* Camera Container with ROI Overlay */
      #container {
        width: 100%;
        aspect-ratio: 16 / 9;
        position: relative;
        margin-top: 1rem;
        border-radius: 12px;
        overflow: hidden;
        background: #e9e9e9;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 3px dashed #aaa;
      }

      #videoPlaceholder {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #555;
        font-size: 1.1rem;
        z-index: 1;
      }

      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 12px;
        display: none;
        z-index: 0;
      }

      /* VIN Scan Area Overlay - CIRCLE (Slightly Larger) */
      #vinScanArea {
        position: absolute;
        top: 50%; /* Center vertically */
        left: 50%; /* Center horizontally */
        transform: translate(-50%, -50%); /* Adjust for its own size */
        height: 90%; /* Increased height to make the circle larger */
        aspect-ratio: 1 / 1; /* Ensures it's a perfect circle (width will match height) */
        border: 3px solid #ffc107;
        border-radius: 50%; /* Makes it a circle */
        z-index: 2;
        pointer-events: none;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5); /* Creates the darkened outside effect */
        display: none;
      }

      /* VIN Result Display (GREEN BLOCK) */
      #vinBox {
        font-weight: bold;
        font-size: 1.2rem;
        color: #28a745;
        margin-top: 1.5rem;
        white-space: pre-wrap;
        text-align: center;
        background: white;
        border: 1px solid #28a745;
        padding: 0.75rem;
        border-radius: 6px;
        min-height: 50px; /* Set a fixed minimum height */
        width: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        overflow-wrap: break-word;
        min-width: 0;
      }

      #vinBox p {
        margin: 0;
        padding: 0;
        max-width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap; /* Allow wrapping for long VINs + confidence */
      }

      #vinBox .confidence {
        font-size: 0.7em;
        color: #555;
        margin-left: 10px; /* Space between VIN and confidence */
        white-space: nowrap; /* Keep confidence on one line */
      }

      /* Scan Button (RED BUTTON) */
      button#toggleScanBtn {
        margin-top: 1.5rem;
        width: 80px;
        height: 80px;
        border-radius: 50%;
        font-weight: bold;
        font-size: 1.1rem; /* Base font size */
        cursor: pointer;
        border: none;
        background-color: red;
        color: white;
        box-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
        transition: background-color 0.3s ease;
        display: flex; /* Use flexbox to center content */
        justify-content: center; /* Center horizontally */
        align-items: center; /* Center vertically */
        margin-left: auto;
        margin-right: auto;
        white-space: nowrap; /* Prevent text wrapping */
        overflow: hidden; /* Hide any overflow */
        position: relative; /* Needed for absolute positioning of dots */
      }

      button#toggleScanBtn.scanning {
        background-color: orange;
        font-size: 0; /* Hide button text completely */
        pointer-events: none; /* Disable clicks while scanning/animating */
      }

      /* --- Animated Round Dots --- */

      /* Individual dot styles (applied to children of ::before, dynamically created) */
      /* We will use a more robust way without direct ::after, ::before content manipulation for dots */
      /* Instead, we'll generate spans for dots within the button and animate them directly */

      /* Let's adjust the structure slightly for better dot control */
      button#toggleScanBtn span.dot {
        display: inline-block; /* Make them inline-block so they sit side by side */
        width: 8px; /* Size of each dot */
        height: 8px;
        background-color: white;
        border-radius: 50%; /* Make them round */
        margin: 0 3px; /* Space between dots */
        opacity: 0; /* Start hidden */
        animation: dotFade 1.5s infinite; /* Animation applied to each dot */
      }

      /* Animation delays for staggered effect */
      button#toggleScanBtn span.dot:nth-child(1) {
        animation-delay: 0s;
      }
      button#toggleScanBtn span.dot:nth-child(2) {
        animation-delay: 0.5s; /* Delay second dot */
      }
      button#toggleScanBtn span.dot:nth-child(3) {
        animation-delay: 1s; /* Delay third dot */
      }

      @keyframes dotFade {
        0%,
        20% {
          opacity: 0; /* Hidden */
        }
        40%,
        80% {
          opacity: 1; /* Visible */
        }
        100% {
          opacity: 0; /* Hidden again */
        }
      }

      /* When not scanning, ensure dots are hidden */
      button#toggleScanBtn:not(.scanning) span.dot {
        display: none;
      }

      /* Styles for the captured image display */
      #capturedImageDisplay {
        display: none;
        margin-top: 1.5rem;
        width: 100%;
        max-width: 480px;
        text-align: center;
        background: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 1rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      #capturedImageDisplay img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
        margin-top: 0.5rem;
      }

      #capturedImageDisplay h3 {
        margin-top: 0;
        margin-bottom: 0.5rem;
        color: #333;
      }

      #capturedImageDisplay p {
        font-size: 0.85rem;
        color: #666;
        margin-bottom: 0;
      }

      /* --- Media Queries for Larger Screens --- */

      @media (min-width: 480px) {
        body {
          padding: 1rem;
        }
        button#toggleScanBtn {
          width: 90px;
          height: 90px;
          font-size: 1.2rem; /* Base font size for larger screens */
        }
        button#toggleScanBtn span.dot {
          width: 10px; /* Larger dots for bigger buttons */
          height: 10px;
        }
      }

      @media (min-width: 600px) {
        #vinBox {
          font-size: 1.4rem;
        }
        #vinBox .confidence {
          font-size: 0.8em;
        }
      }
    </style>
  </head>
  <body>
    <h2>VIN Scanner</h2>

    <div id="mainContent">
      <div id="container">
        <div id="videoPlaceholder">Camera will appear here</div>
        <video id="video" autoplay playsinline></video>
        <div id="vinScanArea"></div>
      </div>

      <div id="vinBox">
        <p>Point camera at VIN and press Start</p>
      </div>

      <button id="toggleScanBtn">
        <span>Start</span>
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
      </button>

      <div id="capturedImageDisplay">
        <h3>Captured Snapshot</h3>
        <img id="displayedCapturedImage" alt="Captured Frame" />
        <p>This is the image used for the last VIN scan.</p>
      </div>
    </div>

    <script>
      const toggleBtn = document.getElementById("toggleScanBtn");
      const toggleBtnText = toggleBtn.querySelector("span:first-child"); // Reference to the "Start/Scan" text span
      const dots = toggleBtn.querySelectorAll(".dot"); // Reference to the dot spans
      const video = document.getElementById("video");
      const vinBox = document.getElementById("vinBox");
      const displayedCapturedImageEl = document.getElementById(
        "displayedCapturedImage"
      );
      const capturedImageDisplayDiv = document.getElementById(
        "capturedImageDisplay"
      );
      const placeholder = document.getElementById("videoPlaceholder");
      const vinScanArea = document.getElementById("vinScanArea");

      let stream = null;
      let cameraOn = false;
      let isScanning = false;

      // --- IMPORTANT: Replace this with your actual Bearer token ---
      // For production, this token should NEVER be hardcoded directly in client-side JS.
      // Consider backend proxies or secure OAuth flows.
      const BEARER_TOKEN = "YOUR_ACTUAL_BEARER_TOKEN_HERE";
      // -------------------------------------------------------------

      async function startCamera() {
        if (!stream) {
          try {
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                facingMode: "environment",
                width: { ideal: 1280 },
                height: { ideal: 720 },
              },
              audio: false,
            });
            video.srcObject = stream;
            video.style.display = "block";
            placeholder.style.display = "none";
            vinScanArea.style.display = "block";
            cameraOn = true;
            toggleBtnText.textContent = "Scan"; // Update this reference
            vinBox.innerHTML = "<p>Align VIN with the yellow circle</p>";

            // Ensure the image display is hidden when camera starts
            displayedCapturedImageEl.src = ""; // Clear previously displayed image
            capturedImageDisplayDiv.style.display = "none";
          } catch (err) {
            const errorMessage =
              "Camera permission denied: " +
              err.message +
              "\nPlease grant camera access to use the scanner.";
            alert(errorMessage);
            console.error("Camera access error:", err);
            return false;
          }
        }
        return true;
      }

      /**
       * Sends the captured image to the server for VIN extraction.
       * @param {string} imageDataUrl The Data URL of the captured image (e.g., "data:image/jpeg;base64,...").
       * @returns {Promise<string|null>} A Promise that resolves with the extracted VIN string, or null if not found/error.
       */
      async function postImageForVinExtraction(imageDataUrl) {
        try {
          vinBox.innerHTML = "<p>Sending image to AI for VIN extraction...</p>";

          const response = await fetch("http://localhost:8080/path", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "Authorization": `Bearer ${BEARER_TOKEN}` // <<< ADDED BEARER TOKEN HERE
            },
            // The OpenAPI client JSON expects 'image' as a Base64 string (without the "data:image/..." prefix)
            // and a 'message' field.
            body: JSON.stringify({
              image: imageDataUrl.split(",")[1], // Extract only the Base64 part
              message: "extract the vin from the image and return the result in the following JSON format {\"vin\": \"<vin-here>\"}",
            }),
          });

          if (!response.ok) {
            // Handle HTTP errors (e.g., 401 Unauthorized, 403 Forbidden, 404, 500)
            const errorText = await response.text();
            throw new Error(
              `Server responded with error: ${response.status} ${response.statusText} - ${errorText}`
            );
          }

          const data = await response.json(); // Parse the JSON response
          console.log("Server response:", data); // Log the full server response for debugging

          // Assuming the server response JSON has a 'vin' field
          if (data && data.vin) {
            return data.vin;
          } else {
            // Server responded OK, but no VIN was found in its response
            return null;
          }
        } catch (error) {
          console.error("Error posting image or processing VIN from server:", error);
          vinBox.innerHTML = `<p style="color: red;">Failed to get VIN from AI. ${
            error.message || "Please check server connection."
          }</p>`;
          return null;
        }
      }

      async function scanFrame() {
        if (isScanning) return; // Prevent multiple scans
        isScanning = true;
        toggleBtn.classList.add("scanning");
        toggleBtnText.style.display = "none"; // Hide the "Scan" text
        dots.forEach(dot => dot.style.display = "inline-block"); // Show dots

        vinBox.innerHTML = "<p>Capturing snapshot...</p>";
        capturedImageDisplayDiv.style.display = "none"; // Hide previous image during new scan

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        const videoIntrinsicWidth = video.videoWidth;
        const videoIntrinsicHeight = video.videoHeight;
        const videoIntrinsicAspect = videoIntrinsicWidth / videoIntrinsicHeight;

        const containerRect = video.parentElement.getBoundingClientRect();
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;
        const containerAspect = containerWidth / containerHeight;

        let renderedVideoWidthInIntrinsicPixels;
        let renderedVideoHeightInIntrinsicPixels;
        let renderedOffsetXInIntrinsicPixels = 0;
        let renderedOffsetYInIntrinsicPixels = 0;

        // Calculate the actual visible portion of the intrinsic video frame due to object-fit: cover
        if (videoIntrinsicAspect > containerAspect) {
          renderedVideoHeightInIntrinsicPixels = videoIntrinsicHeight;
          renderedVideoWidthInIntrinsicPixels =
            videoIntrinsicHeight * containerAspect;
          renderedOffsetXInIntrinsicPixels =
            (videoIntrinsicWidth - renderedVideoWidthInIntrinsicPixels) / 2;
          renderedOffsetYInIntrinsicPixels = 0;
        } else {
          renderedVideoWidthInIntrinsicPixels = videoIntrinsicWidth;
          renderedVideoHeightInIntrinsicPixels =
            videoIntrinsicWidth / containerAspect;
          renderedOffsetXInIntrinsicPixels = 0;
          renderedOffsetYInIntrinsicPixels =
            (videoIntrinsicHeight - renderedVideoHeightInIntrinsicPixels) / 2;
        }

        const scanAreaRect = vinScanArea.getBoundingClientRect();

        // Calculate scan area coordinates relative to the *container* in CSS pixels
        const scanAreaX_css_relative_to_container_untransformed =
          scanAreaRect.left - containerRect.left;
        const scanAreaY_css_relative_to_container_untransformed =
          scanAreaRect.top - containerRect.top;
        const scanAreaWidth_css = scanAreaRect.width;
        const scanAreaHeight_css = scanAreaRect.height;

        // Calculate the scaling factors from CSS pixels (of the rendered container) to intrinsic video pixels
        const scaleFactorX_css_to_intrinsic =
          renderedVideoWidthInIntrinsicPixels / containerWidth;
        const scaleFactorY_css_to_intrinsic =
          renderedVideoHeightInIntrinsicPixels / containerHeight;

        // Calculate the final crop coordinates and dimensions in intrinsic video pixels
        const cropX = Math.max(
          0,
          renderedOffsetXInIntrinsicPixels +
            scanAreaX_css_relative_to_container_untransformed *
              scaleFactorX_css_to_intrinsic
        );
        const cropY = Math.max(
          0,
          renderedOffsetYInIntrinsicPixels +
            scanAreaY_css_relative_to_container_untransformed *
              scaleFactorY_css_to_intrinsic
        );
        const cropWidth = scanAreaWidth_css * scaleFactorX_css_to_intrinsic;
        const cropHeight = scanAreaHeight_css * scaleFactorY_css_to_intrinsic;

        // Set canvas dimensions to the calculated crop dimensions
        canvas.width = cropWidth;
        canvas.height = cropHeight;

        ctx.drawImage(
          video,
          cropX,
          cropY,
          cropWidth,
          cropHeight,
          0,
          0,
          cropWidth,
          cropHeight
        );

        // Convert the cropped image to a Data URL (e.g., JPEG for efficiency)
        const imageDataUrl = canvas.toDataURL("image/jpeg", 0.9); // 0.9 quality for JPEG

        // Display the captured image on the page
        displayedCapturedImageEl.src = imageDataUrl;
        capturedImageDisplayDiv.style.display = "block";

        try {
          // POST the captured image to the server and get the VIN
          const vin = await postImageForVinExtraction(imageDataUrl);

          if (vin) {
            vinBox.innerHTML = `<p>VIN: <a href="http://localhost:4202/vin/${vin}" target="_blank">${vin}</a></p>`;
            console.log("VIN successfully extracted by AI:", vin); // Log the VIN to the console
          } else {
            vinBox.innerHTML = `<p>AI could not find a valid VIN.</p>`;
          }
        } catch (e) {
          console.error("Overall scanFrame error:", e);
          vinBox.innerHTML = `<p style="color: red;">Scan failed: ${
            e.message || "An unexpected error occurred."
          }</p>`;
        } finally {
          isScanning = false;
          toggleBtn.classList.remove("scanning");
          toggleBtnText.style.display = "inline"; // Show the "Scan" text again
          toggleBtnText.textContent = "Scan"; // Reset button text
          dots.forEach(dot => dot.style.display = "none"); // Hide dots
        }
      }

      toggleBtn.addEventListener("click", async () => {
        if (!cameraOn) {
          const ready = await startCamera();
          if (!ready) return;
        } else {
          // Prevent multiple scans if already scanning
          if (isScanning) return;
          await scanFrame();
        }
      });

      window.addEventListener("beforeunload", () => {
        if (stream) {
          stream.getTracks().forEach((track) => track.stop());
        }
      });
    </script>
  </body>
</html>
