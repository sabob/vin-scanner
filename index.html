<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>VIN Scanner (Tesseract.js v5)</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
      #vinBox a {
        color: #28a745;
      }
      /* Global Reset & Box-Sizing */
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        font-family: sans-serif;
        margin: 0;
        background: #f5f5f5;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
        padding: 0.5rem; /* Mobile-first padding */
        position: relative;
        width: 100%;
        overflow-x: hidden;
        /* --- FIX: Keep scrollbar always present to prevent layout shifts --- */
        overflow-y: scroll;
      }

      h2 {
        margin-top: 1rem;
        text-align: center;
        width: 100%;
      }

      /* Main Content Area */
      #mainContent {
        width: 100%;
        max-width: 480px; /* Constrain width on all screens */
        display: flex;
        flex-direction: column;
        align-items: center;
        flex-grow: 1;
        min-width: 0;
      }

      /* Camera Container with ROI Overlay */
      #container {
        width: 100%;
        aspect-ratio: 16 / 9;
        position: relative;
        margin-top: 1rem;
        border-radius: 12px;
        overflow: hidden;
        background: #e9e9e9;
        display: flex;
        justify-content: center;
        align-items: center;
        border: 3px dashed #aaa;
      }

      #videoPlaceholder {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #555;
        font-size: 1.1rem;
        z-index: 1;
      }

      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        border-radius: 12px;
        display: none;
        z-index: 0;
      }

      /* VIN Scan Area Overlay - CIRCLE (Slightly Larger) */
      #vinScanArea {
        position: absolute;
        top: 50%; /* Center vertically */
        left: 50%; /* Center horizontally */
        transform: translate(-50%, -50%); /* Adjust for its own size */
        height: 90%; /* Increased height to make the circle larger */
        aspect-ratio: 1 / 1; /* Ensures it's a perfect circle (width will match height) */
        border: 3px solid #ffc107;
        border-radius: 50%; /* Makes it a circle */
        z-index: 2;
        pointer-events: none;
        box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5); /* Creates the darkened outside effect */
        display: none;
      }

      /* VIN Result Display (GREEN BLOCK) */
      #vinBox {
        font-weight: bold;
        font-size: 1.2rem;
        color: #28a745;
        margin-top: 1.5rem;
        white-space: pre-wrap;
        text-align: center;
        background: white;
        border: 1px solid #28a745;
        padding: 0.75rem;
        border-radius: 6px;
        min-height: 50px; /* Set a fixed minimum height */
        width: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        overflow-wrap: break-word;
        min-width: 0;
      }

      #vinBox p {
        margin: 0;
        padding: 0;
        max-width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap; /* Allow wrapping for long VINs + confidence */
      }

      #vinBox .confidence {
        font-size: 0.7em;
        color: #555;
        margin-left: 10px; /* Space between VIN and confidence */
        white-space: nowrap; /* Keep confidence on one line */
      }

      /* Scan Button (RED BUTTON) */
      button#toggleScanBtn {
        margin-top: 1.5rem;
        width: 80px;
        height: 80px;
        border-radius: 50%;
        font-weight: bold;
        font-size: 1.1rem; /* Base font size */
        cursor: pointer;
        border: none;
        background-color: red;
        color: white;
        box-shadow: 0 0 8px rgba(255, 0, 0, 0.6);
        transition: background-color 0.3s ease;
        display: flex; /* Use flexbox to center content */
        justify-content: center; /* Center horizontally */
        align-items: center; /* Center vertically */
        margin-left: auto;
        margin-right: auto;
        white-space: nowrap; /* Prevent text wrapping */
        overflow: hidden; /* Hide any overflow */
        position: relative; /* Needed for absolute positioning of dots */
      }

      button#toggleScanBtn.scanning {
        background-color: orange;
        font-size: 0; /* Hide button text completely */
        pointer-events: none; /* Disable clicks while scanning/animating */
      }

      /* --- Animated Round Dots --- */

      /* Individual dot styles (applied to children of ::before, dynamically created) */
      /* We will use a more robust way without direct ::after, ::before content manipulation for dots */
      /* Instead, we'll generate spans for dots within the button and animate them directly */

      /* Let's adjust the structure slightly for better dot control */
      button#toggleScanBtn span.dot {
        display: inline-block; /* Make them inline-block so they sit side by side */
        width: 8px; /* Size of each dot */
        height: 8px;
        background-color: white;
        border-radius: 50%; /* Make them round */
        margin: 0 3px; /* Space between dots */
        opacity: 0; /* Start hidden */
        animation: dotFade 1.5s infinite; /* Animation applied to each dot */
      }

      /* Animation delays for staggered effect */
      button#toggleScanBtn span.dot:nth-child(1) {
        animation-delay: 0s;
      }
      button#toggleScanBtn span.dot:nth-child(2) {
        animation-delay: 0.5s; /* Delay second dot */
      }
      button#toggleScanBtn span.dot:nth-child(3) {
        animation-delay: 1s; /* Delay third dot */
      }

      @keyframes dotFade {
        0%,
        20% {
          opacity: 0; /* Hidden */
        }
        40%,
        80% {
          opacity: 1; /* Visible */
        }
        100% {
          opacity: 0; /* Hidden again */
        }
      }

      /* When not scanning, ensure dots are hidden */
      button#toggleScanBtn:not(.scanning) span.dot {
        display: none;
      }

      /* Styles for the captured image display */
      #capturedImageDisplay {
        display: none;
        margin-top: 1.5rem;
        width: 100%;
        max-width: 480px;
        text-align: center;
        background: white;
        border: 1px solid #ddd;
        border-radius: 8px;
        padding: 1rem;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      }

      #capturedImageDisplay img {
        max-width: 100%;
        height: auto;
        border-radius: 4px;
        margin-top: 0.5rem;
      }

      #capturedImageDisplay h3 {
        margin-top: 0;
        margin-bottom: 0.5rem;
        color: #333;
      }

      #capturedImageDisplay p {
        font-size: 0.85rem;
        color: #666;
        margin-bottom: 0;
      }

      /* --- Media Queries for Larger Screens --- */

      @media (min-width: 480px) {
        body {
          padding: 1rem;
        }
        button#toggleScanBtn {
          width: 90px;
          height: 90px;
          font-size: 1.2rem; /* Base font size for larger screens */
        }
        button#toggleScanBtn span.dot {
          width: 10px; /* Larger dots for bigger buttons */
          height: 10px;
        }
      }

      @media (min-width: 600px) {
        #vinBox {
          font-size: 1.4rem;
        }
        #vinBox .confidence {
          font-size: 0.8em;
        }
      }
    </style>
  </head>
  <body>
    <h2>VIN Scanner</h2>

    <div id="mainContent">
      <div id="container">
        <div id="videoPlaceholder">Camera will appear here</div>
        <video id="video" autoplay playsinline></video>
        <div id="vinScanArea"></div>
      </div>

      <div id="vinBox">
        <p>Point camera at VIN and press Start</p>
      </div>

      <button id="toggleScanBtn">
        <span>Start</span>
        <span class="dot"></span>
        <span class="dot"></span>
        <span class="dot"></span>
      </button>

      <div id="capturedImageDisplay">
        <h3>Captured Snapshot</h3>
        <img id="displayedCapturedImage" alt="Captured Frame" />
        <p>This is the image used for the last VIN scan.</p>
      </div>
    </div>

    <script>
      const toggleBtn = document.getElementById("toggleScanBtn");
      const toggleBtnText = toggleBtn.querySelector("span:first-child"); // Reference to the "Start/Scan" text span
      const dots = toggleBtn.querySelectorAll(".dot"); // Reference to the dot spans
      const video = document.getElementById("video");
      const vinBox = document.getElementById("vinBox");
      const displayedCapturedImageEl = document.getElementById(
        "displayedCapturedImage"
      );
      const capturedImageDisplayDiv = document.getElementById(
        "capturedImageDisplay"
      );
      const placeholder = document.getElementById("videoPlaceholder");
      const vinScanArea = document.getElementById("vinScanArea");

      let stream = null;
      let cameraOn = false;
      let isScanning = false;
      let worker = null; // Declare worker globally

      // Initialize Tesseract.js worker
      async function initializeTesseractWorker() {
        if (worker) return; // Worker already initialized

        vinBox.innerHTML = "<p>Loading OCR engine...</p>";

        worker = await Tesseract.createWorker("eng", 3, {
          logger: (m) => {
            if (m.status === "loading" || m.status === "initializing") {
              vinBox.innerHTML = `<p>Loading OCR: ${Math.round(
                m.progress * 100
              )}%</p>`;
            } else if (m.status === "recognizing") {
              vinBox.innerHTML = `<p>Scanning: ${Math.round(
                m.progress * 100
              )}%</p`;
            }
          },
        });

        await worker.setParameters({
          tessedit_char_whitelist: "ABCDEFGHJKLMNPRSTUVWXYZ0123456789",
          psm: 7,
        });

        vinBox.innerHTML = "<p>Point camera at VIN and press Start</p>";
      }

      async function startCamera() {
        if (!stream) {
          try {
            stream = await navigator.mediaDevices.getUserMedia({
              video: {
                facingMode: "environment",
                width: { ideal: 1280 },
                height: { ideal: 720 },
              },
              audio: false,
            });
            video.srcObject = stream;
            video.style.display = "block";
            placeholder.style.display = "none";
            vinScanArea.style.display = "block";
            cameraOn = true;
            toggleBtnText.textContent = "Scan"; // Update this reference
            vinBox.innerHTML = "<p>Align VIN with the yellow circle</p>";

            // Ensure the image display is hidden when camera starts
            displayedCapturedImageEl.src = ""; // Clear previously displayed image
            capturedImageDisplayDiv.style.display = "none";

            // Pre-load Tesseract.js worker when camera starts
            await initializeTesseractWorker();
          } catch (err) {
            const errorMessage =
              "Camera permission denied: " +
              err.message +
              "\nPlease grant camera access to use the scanner.";
            alert(errorMessage);
            console.error("Camera access error:", err);
            return false;
          }
        }
        return true;
      }

      async function scanFrame() {
        if (isScanning || !worker) return;
        isScanning = true;
        toggleBtn.classList.add("scanning");
        toggleBtnText.style.display = "none"; // Hide the "Scan" text

        vinBox.innerHTML = "<p>Scanning...</p>";
        capturedImageDisplayDiv.style.display = "none"; // Hide image during scan to show new one

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");

        const videoIntrinsicWidth = video.videoWidth;
        const videoIntrinsicHeight = video.videoHeight;
        const videoIntrinsicAspect = videoIntrinsicWidth / videoIntrinsicHeight;

        const containerRect = video.parentElement.getBoundingClientRect(); // The #container element
        const containerWidth = containerRect.width;
        const containerHeight = containerRect.height;
        const containerAspect = containerWidth / containerHeight;

        let renderedVideoWidthInIntrinsicPixels;
        let renderedVideoHeightInIntrinsicPixels;
        let renderedOffsetXInIntrinsicPixels = 0;
        let renderedOffsetYInIntrinsicPixels = 0;

        // Calculate the actual visible portion of the intrinsic video frame due to object-fit: cover
        if (videoIntrinsicAspect > containerAspect) {
          // Video is wider than container aspect. It fills the height of the container,
          // and gets cropped horizontally.
          renderedVideoHeightInIntrinsicPixels = videoIntrinsicHeight;
          renderedVideoWidthInIntrinsicPixels =
            videoIntrinsicHeight * containerAspect;
          renderedOffsetXInIntrinsicPixels =
            (videoIntrinsicWidth - renderedVideoWidthInIntrinsicPixels) / 2;
          renderedOffsetYInIntrinsicPixels = 0;
        } else {
          // Video is taller than container aspect. It fills the width of the container,
          // and gets cropped vertically.
          renderedVideoWidthInIntrinsicPixels = videoIntrinsicWidth;
          renderedVideoHeightInIntrinsicPixels =
            videoIntrinsicWidth / containerAspect;
          renderedOffsetXInIntrinsicPixels = 0;
          renderedOffsetYInIntrinsicPixels =
            (videoIntrinsicHeight - renderedVideoHeightInIntrinsicPixels) / 2;
        }

        const scanAreaRect = vinScanArea.getBoundingClientRect();

        // Calculate scan area coordinates relative to the *container* in CSS pixels
        // These will be relative to the top-left of the container, before transform is applied
        const scanAreaX_css_relative_to_container_untransformed =
          scanAreaRect.left - containerRect.left;
        const scanAreaY_css_relative_to_container_untransformed =
          scanAreaRect.top - containerRect.top;
        const scanAreaWidth_css = scanAreaRect.width;
        const scanAreaHeight_css = scanAreaRect.height;

        // Calculate the scaling factors from CSS pixels (of the rendered container) to
        // intrinsic video pixels (of the effectively displayed intrinsic video area)
        const scaleFactorX_css_to_intrinsic =
          renderedVideoWidthInIntrinsicPixels / containerWidth;
        const scaleFactorY_css_to_intrinsic =
          renderedVideoHeightInIntrinsicPixels / containerHeight;

        // Calculate the final crop coordinates and dimensions in intrinsic video pixels
        // These are the arguments for ctx.drawImage's source rectangle
        const cropX = Math.max(
          0,
          renderedOffsetXInIntrinsicPixels +
            scanAreaX_css_relative_to_container_untransformed *
              scaleFactorX_css_to_intrinsic
        );
        const cropY = Math.max(
          0,
          renderedOffsetYInIntrinsicPixels +
            scanAreaY_css_relative_to_container_untransformed *
              scaleFactorY_css_to_intrinsic
        );
        const cropWidth = scanAreaWidth_css * scaleFactorX_css_to_intrinsic;
        const cropHeight = scanAreaHeight_css * scaleFactorY_css_to_intrinsic;

        // Set canvas dimensions to the calculated crop dimensions
        canvas.width = cropWidth;
        canvas.height = cropHeight;

        ctx.drawImage(
          video,
          cropX,
          cropY,
          cropWidth,
          cropHeight,
          0,
          0,
          cropWidth,
          cropHeight
        );

        displayedCapturedImageEl.src = canvas.toDataURL("image/png"); // Set image source

        try {
          const result = await worker.recognize(canvas);

          const vinMatch = result.data.text.match(/\b[A-HJ-NPR-Z0-9]{17}\b/);
          if (vinMatch) {
            const vin = vinMatch[0];
            const confidence = result.data.confidence
              ? result.data.confidence.toFixed(1)
              : "N/A";
            vinBox.innerHTML = `<p>VIN: <a href="http://localhost:4202/vin/${vin}" target="_blank">${vin}</a> <span class="confidence">(${confidence}%)</span></p>`;
          } else {
            vinBox.innerHTML = `<p>No valid 17-character VIN found.</p>`;
          }

          // Always display the image after a scan is attempted
          capturedImageDisplayDiv.style.display = "block";
        } catch (e) {
          console.error("OCR error:", e);
          vinBox.innerHTML = `<p style="color: red;">OCR Error: ${
            e.message || "Check console."
          }</p>`;
          // Always display the image even if OCR fails
          capturedImageDisplayDiv.style.display = "block";
        } finally {
          // --- PAUSE REMOVED HERE ---
          isScanning = false;
          toggleBtn.classList.remove("scanning");
          toggleBtnText.style.display = "inline"; // Show the "Scan" text again
          toggleBtnText.textContent = "Scan"; // Reset button text
        }
      }

      toggleBtn.addEventListener("click", async () => {
        if (!cameraOn) {
          const ready = await startCamera();
          if (!ready) return;
        } else {
          // Prevent multiple scans if already scanning or worker initializing
          if (isScanning) return;

          // Ensure worker is ready before scanning
          if (!worker) {
            vinBox.innerHTML = "<p>Initializing OCR engine, please wait...</p>";
            // Briefly set the button to "..." while worker initializes
            toggleBtn.classList.add("scanning");
            toggleBtnText.style.display = "none";

            await initializeTesseractWorker();

            // After worker init, if not yet scanning, prepare for scan or reset
            if (!isScanning) {
                toggleBtn.classList.remove("scanning");
                toggleBtnText.style.display = "inline";
                toggleBtnText.textContent = "Scan";
            }
          }
          await scanFrame();
        }
      });

      window.addEventListener("beforeunload", () => {
        if (stream) {
          stream.getTracks().forEach((track) => track.stop());
        }
        if (worker) {
          worker.terminate(); // Terminate worker to free up resources
        }
      });
    </script>
  </body>
</html>
